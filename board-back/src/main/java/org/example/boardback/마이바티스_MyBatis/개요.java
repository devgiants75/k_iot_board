package org.example.boardback.마이바티스_MyBatis;

// ============================================================
// 1. MyBatis란 무엇인가
// ============================================================
//
// 1-1) MyBatis의 정의
//  - MyBatis는 "SQL 매퍼 프레임워크"
//  - 핵심 아이디어
//      → 개발자가 직접 작성한 SQL을
//      → 자바 객체에 매핑해주는 역할을 담당
//  - ORM(Object-Relational Mapping) 프레임워크인 JPA와 달리,
//    "SQL 중심" + "매핑 편의 기능" 제공에 초점이 맞춰져 있음
//
// 1-2) MyBatis의 위치
//  - JDBC를 직접 사용할 때:
//      → Connection / PreparedStatement / ResultSet을 직접 관리해야 하고,
//        SQL, 파라미터 바인딩, 결과 매핑 등을 모두 수동으로 처리해야 함
//  - MyBatis는:
//      → SQL은 개발자가 직접 쓰되,
//      → 파라미터 바인딩, 결과 매핑, 반복적인 JDBC 코드 등을 대신 처리해줌
//  - 즉, "JDBC 위에 올라간 SQL 매퍼"로 볼 수 있음
//
// 1-3) MyBatis의 간단한 동작 이미지
//  - Mapper 인터페이스: 자바 메서드 정의 (ex. findUserById(Long id))
//  - Mapper XML: 그 메서드와 매핑되는 <select>, <insert> 등 SQL 정의
//  - MyBatis 실행 흐름:
//      1) 클라이언트 코드에서 mapper.findUserById(1L) 호출
//      2) MyBatis가 해당 메서드에 매핑된 SQL(XML)을 찾음
//      3) 파라미터(1L)를 SQL에 바인딩해서 JDBC로 실행
//      4) ResultSet 결과를 User 객체로 변환해서 반환
//
// 1-4) JPA와의 큰 차이 포인트(요약)
//  - JPA: "엔티티 중심" / "객체 모델 설계" / "영속성 컨텍스트" / "변경 감지"
//  - MyBatis: "SQL 중심" / "쿼리 직접 작성" / "영속성 컨텍스트 없음" / "변경 감지 없음"
//

// ============================================================
// 2. MyBatis 사용 목적
// ============================================================
//
// 2-1) SQL을 직접 컨트롤하고 싶을 때
//  - 복잡한 조인, 집계 함수, 윈도우 함수, 서브쿼리 등
//    고난이도 SQL을 자주 사용해야 하는 도메인:
//      예) 통계/리포팅, 데이터 마이닝, DW, 조회 특화 API, 검색 조건이 매우 다양한 화면 등
//  - JPA로도 JPQL/Native Query로 작성 가능하지만,
//      복잡도가 매우 올라가고, 가독성이 떨어지는 경우가 많음
//  - 이럴 때 MyBatis로 "SQL을 1차 시민"으로 두고, 명시적으로 관리하는 것이 유리

// 2-2) DB 튜닝, 쿼리 튜닝이 자주 필요한 환경
//  - 서비스에서 쿼리 성능이 매우 중요한 경우,
//    DBA와 협업하여 SQL을 미세하게 쪼개고 튜닝하는 일이 많음
//  - MyBatis는 SQL이 XML에 "그대로" 남아 있으므로:
//      → DBA가 SQL만 보고도 이해하기 쉬움
//      → 쿼리 튜닝, 인덱스 전략 수립이 용이
//
// 2-3) Legacy 시스템 연동
//  - 기존 시스템이 Stored Procedure 중심 또는 특정 SQL 패턴 중심으로 구성되어 있을 때,
//      이러한 SQL 기반 구조에 MyBatis가 잘 맞음
//  - JPA는 엔티티 매핑 중심이므로,
//      복잡한 SP 기반 시스템과 직접 맞추기 까다로울 수 있음
//
// 2-4) 빠른 개발이 필요한 단순 CRUD + 약간의 복잡한 조회
//  - 단순 CRUD만 있으면 JPA가 더 편할 수 있음
//  - 하지만 프로젝트 초기에 도메인이 자주 바뀌고,
//    "엔티티 설계"보다 "화면 요구사항 중심"으로 빠르게 API를 맞추고 싶을 때,
//      MyBatis로 화면별 SQL을 직접 작성하면
//      요구사항 대응과 변경에 직관적으로 대응하기 쉬움

// ============================================================
// 3. JPA vs MyBatis 차이
// ============================================================
//
// 3-1) 중심 사고의 차이
//  - JPA: "객체 중심"
//      → 엔티티 설계가 먼저, DB 테이블은 그 결과물
//      → 비즈니스 로직을 엔티티 중심으로 구현
//  - MyBatis: "SQL 중심"
//      → 화면/요구사항에 맞는 SQL을 먼저 설계
//      → 결과를 담을 DTO 또는 도메인 객체를 나중에 맞춤
//
// 3-2) 영속성 컨텍스트 / 1차 캐시 / 변경 감지
//  - JPA:
//      → EntityManager / 영속성 컨텍스트를 통해
//         1차 캐시, 변경 감지(Dirty Checking), 지연 로딩(Lazy Loading) 수행
//      → "엔티티를 가져온 뒤 필드만 바꾸면 트랜잭션 종료 시 자동으로 UPDATE" 같은 기능 제공
//  - MyBatis:
//      → 이런 개념 없음
//      → 조회: select...  / 수정: update...  / 삭제: delete... 를 각각 명시적으로 호출해야 함
//      → 상태 변경을 자동 추적하지 않음
//
// 3-3) SQL의 위치와 형태
//  - JPA:
//      → 기본적으로는 메서드 이름 기반 쿼리, JPQL, Criteria API, QueryDSL 등을 사용
//      → SQL을 숨기거나 추상화해서 "객체 중심" 사고를 유지
//      → Native Query도 가능하지만, 유지보수 포인트가 분산되기 쉬움
//  - MyBatis:
//      → SQL이 XML이나 어노테이션에 명시적으로 존재
//      → SQL을 직접 보고, 바로 이해하고, 수정하는 스타일
//
// 3-4) 매핑 방식
//  - JPA:
//      → @Entity, @Table, @Column 등으로 객체-테이블 매핑
//      → 복잡한 연관관계(1:N, N:1, N:M)를 매핑하고,
//        이를 통해 객체 그래프 탐색으로 데이터를 조회하는 방식
//  - MyBatis:
//      → ResultMap 또는 자동 매핑으로 ResultSet → 객체 매핑
//      → 연관 관계를 자동으로 추적하지 않음
//      → 주로 테이블 조인을 SQL에서 직접 작성하고, 그 결과를 DTO에 매핑
//
// 3-5) 복잡한 조회에서의 차이
//  - JPA:
//      → 엔티티 그래프 탐색, JPQL, QueryDSL로 표현
//      → 복잡한 통계/집계/특수 함수(윈도우 함수 등)는 결국 Native Query로 가는 경우 많음
//  - MyBatis:
//      → 처음부터 SQL 기반이므로
//        복잡한 조회를 DB 벤더 특화 기능까지 활용하여 직접 작성하기 쉬움
//
// 3-6) 학습 난이도 / 디버깅 관점
//  - JPA:
//      → 개념이 많다: 영속성 컨텍스트, 엔티티 상태, 연관관계 매핑, 지연 로딩, 캐시, Flush, 트랜잭션 등
//      → 잘못 사용하면 N+1, 불필요한 쿼리, 성능 이슈 등 디버깅이 어려움
//  - MyBatis:
//      → 개념은 단순(Mapper, SQL, 파라미터/결과 매핑)
//      → 쿼리가 명확히 보이므로 "어떤 SQL이 나가는지" 직관적으로 이해하기 쉬움

// ============================================================
// 4. MyBatis의 장점 / 단점
// ============================================================
//
// 4-1) 장점
//  - (1) SQL 가시성
//      → 실제 실행되는 쿼리가 XML에 그대로 있으므로
//        디버깅 및 분석이 용이
//  - (2) SQL의 자유도
//      → DB 벤더에 특화된 기능(예: Oracle 힌트, MySQL 함수, 윈도우 함수 등)을
//        제약 없이 사용 가능
//  - (3) 복잡 조회에 강함
//      → 화면/리포트에 맞춘 복잡한 SELECT 문 작성이 JPA보다 직관적임
//  - (4) 러닝 커브가 상대적으로 완만
//      → JPA의 영속성, 연관관계, 엔티티 상태 등 복잡한 개념에 비해
//        이해할 개념이 비교적 단순
//
// 4-2) 단점
//  - (1) 반복되는 SQL
//      → 단순 CRUD도 직접 SQL을 작성해야 하므로 코드 양이 많아짐
//  - (2) DB 종속성 증가
//      → SQL을 많이, 깊게 사용할수록 특정 DB에 종속되는 경향이 생김
//  - (3) 객체 지향 도메인 모델 구현이 어려움
//      → 도메인 객체가 풍부한 비즈니스 로직을 가지는 DDD 스타일에서,
//        MyBatis는 단순히 "데이터 운반용"으로 사용되는 경향이 강함
//  - (4) 변경 감지, 1차 캐시 지원 없음
//      → 동일 트랜잭션 내에서 엔티티 상태 변경 자동 반영 같은 기능이 없으므로
//        변경 로직을 직접 다 관리해야 함
//
// 4-3) JPA와 비교한 장점/단점 요약
//  - MyBatis 장점:
//      → SQL 가시성, 복잡 조회/튜닝 유리, 러닝 커브 비교적 낮음
//  - MyBatis 단점:
//      → 엔티티 중심 도메인 모델링 지원 부족,
//        단순 CRUD도 SQL 작성 필요, 변경 감지 없음

// ============================================================
// 5. MyBatis 기본 구성 요소
// ============================================================
//
// 5-1) SqlSessionFactory
//  - SqlSession을 생성하는 팩토리
//  - 스프링 부트에서는 주로 MyBatis-Spring-Boot-Starter가
//    자동 설정을 통해 SqlSessionFactory를 빈으로 등록
//
// 5-2) SqlSession
//  - 실제로 DB와 통신하는 핵심 객체
//  - Mapper 인터페이스를 통해 더 추상화해서 사용하므로
//    실무에서 직접 SqlSession을 다루는 일은 많지 않음
//
// 5-3) Mapper 인터페이스
//  - "DAO 역할"을 하는 인터페이스
//  - 예) UserMapper {
//          User findById(Long id);
//          void insert(User user);
//        }
//  - MyBatis가 이 인터페이스를 동적 프록시로 구현해주고,
//    각 메서드 호출을 XML에 정의된 SQL과 연결해 실행
//
// 5-4) Mapper XML 파일
//  - 실제 SQL이 들어 있는 XML.
//  - <mapper namespace="..."> 안에 <select>, <insert>, <update>, <delete> 태그로 쿼리를 정의한
//  - 각 SQL 태그에는 id가 있고, 이 id와 Mapper 인터페이스의 메서드를 매핑
//
// 5-5) 스프링 부트 + MyBatis 통합
//  - 보통 다음과 같은 형태로 사용:
//      → @Mapper 어노테이션 (혹은 @MapperScan 설정)으로 Mapper 인터페이스를 스캔
//      → 스프링이 Mapper 인터페이스를 빈으로 등록
//      → 서비스 계층에서 @Autowired 또는 생성자 주입으로 Mapper 사용

// ============================================================
// 6. 실무에서 JPA + MyBatis 혼용 패턴
// ============================================================
//
// "JPA도 쓰고, MyBatis도 동시에 쓰면 안 좋은 것 아닌가?"
// → 결론: "섞어 쓰는 것 자체"는 문제가 아니다.
//         다만, "역할 분리"와 "일관된 기준"이 중요
//
// === 실무에서 많이 사용하는 혼용 패턴 ===
//
// 6-1) 패턴 1: 쓰기/도메인 로직은 JPA, 복잡 조회는 MyBatis
//  - 기본 아이디어:
//      → "도메인 모델과 밀접한 CRUD, 비즈니스 로직"은 JPA로 처리
//      → "화면/리포트용 복잡 조회, 페이징, 통계"는 MyBatis로 처리
//
//  - JPA가 담당하기 좋은 영역:
//      * 엔티티 중심의 도메인 모델링
//      * 트랜잭션 안에서의 상태 관리(변경 감지)
//      * 연관관계를 활용한 비즈니스 로직 (ex. 주문-주문상품-상품)
//  - MyBatis가 담당하기 좋은 영역:
//      * 한 화면에서 여러 테이블을 복잡하게 조인해 보여주는 조회
//      * 리포트/대시보드용 집계/통계 쿼리
//      * DB 특화 기능을 많이 사용해야 하는 쿼리
//
//  예시)
//      - 주문(Order) 생성, 수정, 취소 → JPA 엔티티 + 리포지토리 사용
//      - "지난 달 주문 통계", "사용자별 매출 TOP 10" → MyBatis로 SQL 작성
//
//  장점:
//      - 비즈니스 로직은 JPA 덕분에 객체 지향적으로 구현
//      - 조회/리포트는 MyBatis로 직관적이고 튜닝 가능한 SQL 작성
//
//  단점/주의점:
//      - 같은 테이블을 JPA와 MyBatis가 동시에 만질 경우,
//          캐시, 영속성 컨텍스트, 트랜잭션 경계에 대한 이해가 필요
//      - 같은 트랜잭션 안에서 JPA와 MyBatis를 함께 사용하는 경우,
//          순서에 따라 아직 Flush 되지 않은 변경이 DB에 반영되지 않았을 수 있으므로 주의
//
//  → 실무 팁:
//      * "쓰기" 관련 로직에서 JPA를 사용하고 있을 때,
//        같은 트랜잭션 안에서 MyBatis로 곧바로 조회하면
//        JPA가 DB에 flush 하지 않은 변경이 반영되지 않을 수 있음!!!!!
//      * 이 경우, JPA 쪽에서 flush()를 명시적으로 호출하거나,
//        한 트랜잭션 안에서 쓰기/조회 방향을 잘 설계하는 것이 중요!!!!!
//
// 6-2) 패턴 2: 레거시 모듈은 MyBatis, 신규 모듈은 JPA
//  - 기존 시스템이 MyBatis(또는 iBatis) 기반일 때,
//    점진적으로 도메인을 JPA로 옮겨가면서 혼용하는 경우
//
//  - 전략:
//      * 기존 모듈(이미 SQL이 다 작성됨): MyBatis 유지
//      * 새로 만드는 모듈/도메인: JPA로 설계
//
//  - 장점:
//      * 기존 코드 안정성 유지
//      * 새 도메인에는 JPA의 장점을 활용하여 설계
//
//  - 주의:
//      * 장기적으로 "JPA와 MyBatis가 섞인 혼종 레이어"가 되지 않도록
//        모듈/패키지 레벨에서 경계를 명확하게 나누는 것이 좋음
//
// 6-3) 패턴 3: 특정 DB 기능/스토어드 프로시저만 MyBatis로 래핑
//  - JPA로 대부분 처리하지만,
//    특정 복잡 SP(Stored Procedure) 호출이나 DB 전용 기능은
//    MyBatis Mapper로 한 번 래핑해서 사용
//
//  - 예:
//      * 월말 배치 처리, 정산 모듈에서 복잡한 SP를 호출해야 할 때
//      * JPA에서는 SP 호출이 번거롭고 제한이 있을 수 있음!
//        MyBatis Mapper로 간단히 래핑해서 사용!
//
//  - 사용 패턴:
//      * @Service는 JPA 리포지토리와 MyBatis Mapper를 동시에 주입 가능
//      * JPA는 엔티티 라이프사이클/비즈니스 로직,
//        MyBatis는 특정 SP 호출이나 복잡한 SQL만 담당

// ============================================================
// 7. JPA와 MyBatis 혼용 시 설계 기준 & 베스트 프랙티스
// ============================================================
//
// 7-1) "누가 무엇을 담당할지"를 먼저 정하기!
//  - 추천 기준:
//      * "엔티티 중심 도메인 로직(쓰기/비즈니스 규칙)": JPA
//      * "복잡 조회, 리포트, 성능 민감 SQL": MyBatis
//
//  - 안 좋은 예:
//      * 같은 기능에 대해 JPA, MyBatis 구현이 섞여 사용되는 경우
//      * 개발자마다 취향대로 JPA 또는 MyBatis를 골라 쓰는 경우
//
// 7-2) 패키지/모듈 구조로 경계 잡기             ※ 팀 컨벤션이 제일 중요합니다!!! ※
//  - 예시 구조:
//      com.example.domain.order
//          ├─ entity (JPA 엔티티)
//          ├─ repository (JPA Repository)
//          ├─ service (비즈니스 로직)
//          └─ query (MyBatis Mapper + DTO, 복잡 조회 전용)
//
//  - 또는:
//      com.example.persistence.jpa
//      com.example.persistence.mybatis
//      처럼 기술별로 모듈을 분리하고,
//      service 계층에서 두 모듈을 사용하도록 설계
//
// 7-3) 엔티티 vs DTO 분리
//  - JPA 엔티티는 "도메인 모델" 역할에 집중
//  - MyBatis로 복잡 조회를 할 때는
//      → 화면/리포트에 딱 맞는 형태의 DTO를 별도로 정의해서 사용 (엔티티 직접 사용 X)
//
//  - 이유
//      * 엔티티에 화면 전용 필드가 계속 추가되면
//        도메인 모델이 화면 요구사항에 끌려다니게 됨
//      * DTO 분리를 통해 도메인 모델의 순수성을 유지 가능
//
// 7-4) 트랜잭션 경계 주의
//  - @Transactional 메서드 안에서 JPA와 MyBatis를 함께 사용할 때
//      * JPA가 변경한 내용을 MyBatis로 조회하려면
//        명시적으로 flush() 해야 하거나,
//        JPA 작업이 끝난 후에 MyBatis 조회를 하도록 순서를 정리!!! ※ 해당 문제로 오류 많이 납니다! ※
//
//  - 일반적인 추천
//      * "쓰기"는 가능하면 한 기술(JPA)로 끝내고
//        "읽기" 전용 쿼리는 서비스 계층 경계에서 따로 분리
//
// 7-5) 일관된 코드 스타일 가이드 문서화
//  - 팀 내 규칙 예시
//      * 기본 CRUD는 JPA 사용
//      * 통계/리포팅/대시보드용 API는 MyBatis 사용!!!!!      >>>>>>>>>> 그래서 프로젝트에 한 사람 당 통계 기능 1개 이상 씩 구현 했으면 합니다
//      * MyBatis Mapper XML은 모듈별로 디렉토리 분리
//      * JPA 엔티티는 MyBatis에서 직접 사용하지 않는다(필요 시 별도 DTO).
//
//  - 이런 규칙을 "문서화"하고 코드 리뷰에서 체크하면 혼용에 따른 혼란 감소 ※ 팀 컨벤션이 제일 중요합니다!!! ※

// ============================================================
// 정리
// ============================================================
//
//  - MyBatis는 "SQL 중심" SQL 매퍼 프레임워크이다
//  - JPA는 "객체/엔티티 중심" ORM 프레임워크이다
//  - 두 가지를 대체 관계로 볼 수도 있지만,
//    실무에서는 "역할을 분리해서 함께 쓰는" 경우가 매우 흔함 (혼용!)
//
//  - JPA에 이미 익숙한 상태에서 MyBatis를 학습할 때의 문법 적용 상황
//      1) 이 기능은 "도메인 로직"에 더 가까운가? → JPA가 적합할 확률↑
//      2) 이 기능은 "복잡한 조회/리포트/튜닝"에 더 가까운가? → MyBatis가 적합할 확률↑
//
//  - 중요한 것은 "기술 그 자체" 보다
//    "팀과 프로젝트에서 일관된 기준을 정하고 지키는 것" ※ 팀 컨벤션이 제일 중요합니다!!! ※

public class 개요 {
}
